[TOC]
## 什么是同源策略
同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。可以说Web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。
### 同源含义
所谓"同源"指的是"三个相同"。
- 协议相同，如都是http或者https。
- 域名相同，如都是http://baidu.com/a和http://baidu.com/b，即host相同。
- 端口相同，如都是80端口，默认不写的话是80端口。

### 同源策略分类

另外，同源策略又分为以下三种：

- Cookie、LocalStorage 和 IndexDB 同源策略：只有同源的网页才能共享。
- DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。
- XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。

但是有`<script><img><iframe><link><video><audio>`等带有`src`或`href`属性的标签是允许跨域加载资源的，这是因为：

- 现在很多大型网站的js脚本、图片等都不是存放在存储网站页面的那台服务器上，他们很可能通过CDN等方式传送到浏览器端。

- 一个网站要加载哪些脚本，由网站的编写人员说了算，他们不会故意加载恶意脚本，所以只要是写在网页中的脚本，我们认为它是安全的。

- 所以，a.com的网页中可以写`<script src="b.com/test.js"></script>`，a网站加载了b网站的脚本，这是完全可以的，不受任何限制。

## 如何跨域访问
### AJAX请求
#### JSONP
在JS中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的JS脚本文件却是可以的，JSONP正是利用这个特性来实现的。

比如我们在http://localhost:3000.com里面用ajax请求http://localhost:3001.com/getData接口，浏览器会报错：
![](./images/21.png)

错误显示不能在localhost:3000的脚本里面通过ajax向localhost:3001发请求，因为他们是跨域的。

http://localhost:3000.com 前端和服务端代码：

```
// 前端
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>A</title>
</head>
<body>
    <div>我是A页面</div>
    <script>
        var xhr = new XMLHttpRequest();
        xhr.open('get', 'http://localhost:3001/getData');
        xhr.send();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                alert(xhr.responseText);
            }
        };

    </script>
</body>
</html>

// 服务端
const Koa = require('koa');
const app = new Koa();
const router = require('koa-router')();
const fs = require('fs');

// response
router.get('/', async (ctx, next) => {
    let data = fs.readFileSync('index.html', 'utf-8');
    ctx.body = data;
})
app.use(router.routes());
app.listen(3000);
```
http://localhost:3001.com 服务端代码：
```
const Koa = require('koa')
// 注意 require('koa-router') 返回的是函数:
const router = require('koa-router')()
const app = new Koa()

// 添加路由
router.get('/getData', async (ctx, next) => {
    ctx.body = 'hello world';
})

// 调用路由中间件
app.use(router.routes())
app.listen(3001, () => {
    console.log('server is running at http://localhost:3001')
})
```
JSONP是“JSON with Padding”的略称，可以让网页从别的域名（网站）那获取资料，即跨域读取数据，将JSON数据填充进回调函数callback。

步骤如下：
- 首先在客户端注册一个callback, 然后把callback的名字传给服务器。
- 服务器先生成 json 数据。
- 然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的参数 jsonp.
- 将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。
- 客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）

http://localhost:3000.com 前端代码，通过script标签加载接口，并将定义好的回调函数以query的形式添加到接口后面。
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>A</title>
</head>
<body>
    <div>我是A页面</div>
    <script>
        function addScriptTag(src) {
            var script = document.createElement('script');
            script.setAttribute("type", "text/javascript");
            script.src = src;
            document.body.appendChild(script);
        }

        window.onload = function () {
            addScriptTag('http://localhost:3001/getData?callback=log');
        }

        function log(data) {
            alert(data);
        };
    </script>
</body>
</html>
```

http://localhost:3000.com 服务端代码，服务端将callback 和 要返回的json数据 拼接成字符串返回。
```
const Koa = require('koa')
// 注意 require('koa-router') 返回的是函数:
const router = require('koa-router')()
const app = new Koa()

// 添加路由
router.get('/getData', async (ctx, next) => {
    let data = 'hello world';
    console.log(ctx.request.query);
    let { callback } = ctx.request.query;
    ctx.body = `${callback}('hello world')`;
})

// 调用路由中间件
app.use(router.routes())
app.listen(3001, () => {
    console.log('server is running at http://localhost:3001')
})
```
#### CORS
CORS全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

详细参考 阮一峰老师 [跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html) 的介绍。

因此上面的例子，http://localhost:3000.com中前端的代码还是可以用ajax发请求，http://localhost:3001.com服务端的代码需要往响应头加入一些参数。

http://localhost:3000.com前端代码:

```
var xhr = new XMLHttpRequest();
xhr.open('get', 'http://localhost:3001/getData');
xhr.send();
xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
        alert(xhr.responseText);
    }
}; 
```
http://localhost:3001.com服务端代码:

```
router.get('/getData', async (ctx, next) => {
    let data = 'hello world';
    ctx.set("Access-Control-Allow-Origin", '*')
    ctx.body = 'hello world';
})
```
![](./images/22.png)
如上图所示，在A页面中给这个接口`http://localhost:3001/getData`发请求时，会在请求头上添加`origin:Origin: http://localhost:3000`，`http://localhost:3001/getData`收到请求时，如果觉得可以响应数据，就会在响应头上添加`Access-Control-Allow-Origin: *`，浏览器收到响应后，发现`origin`属于响应头`Access-Control-Allow-Origin`的值包含的范围内，就会把数据返回给A页面。
### DOM 同源策略