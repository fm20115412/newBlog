### 一、[Remove Element题目链接](https://leetcode.com/problems/remove-element/)
### 二、思路
首先需要明确以下两点：
1. 数组未排序;
2. 你需要在原地删除重复出现的元素，即不能使用额外的数组空间;
3. 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素

#### a. 双指针
我们可以放置两个指针i和j，其中i是慢指针，j是快指针，只要$nums[j] == val$,我们就递增j以跳过重复项；当$nums[j] != val$,跳过重复项的运行已经结束，因此我们必须把它nums[j]的值复制到nums[i]，然后递增i。
```
var removeElement = function(nums, val) {
    let i = 0;
    for(let j=0;j<nums.length;j++){
        if(nums[j] != val){
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
};
```
**时间复杂度：** $O(n)$

**空间复杂度：** $O(1)$
#### b. 双指针---当要删除的元素很少时
现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，val=4。似乎没有必要将 [1，2，3，5]这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。

当我们遇到$nums[i] == val$时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。

```
var removeElement = function(nums, val) {
    let n = nums.length;
    let i = 0;
    while(i<n){
        if(nums[i] == val){
           nums[i] = nums[n-1];
            n--;
        }else{
            i++
        }
    }
    return n;
};
```

**时间复杂度：** $O(n)$,i 和 n最多遍历 n 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。

**空间复杂度：** $O(1)$


