### 第2题 ['1', '2', '3'].map(parseInt) what & why ?
**输出：** [1, NaN, NaN]，哈哈，想不到吧！
**解答：**
map函数的第一个参数callback：
```
var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
```
这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引，第三个参数是map方法调用的数组。

parseInt(string, radix) 则是用来解析字符串的，**把string所对应的值当做radix对应的进制看待，然后转换成相应的10进制值。**


| string |                                                                                            必需。要被解析的字符串。                                                                                            |
| :----: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| radix  | 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 |

因此上面等价于：
```
['1', '2', '3'].map((item, index) => {
	return parseInt(item, index)
})

parseInt('1', 0) // 1
parseInt('2', 1) // NaN
parseInt('3', 2) // NaN, 二进制中没有3
```
### 第31题
改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。
```
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
```
**改造1：**
- 利用 let 变量的特性 — 在每一次 for 循环的过程中，let 声明的变量会在当前的块级作用域里面（for 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（Lexical Environment），该环境里面包括了当前 for 循环过程中的 i。
```
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}
```
**改造2：**
- 利用函数自执行的方式，把当前 for 循环过程中的 i 传递进去，构建出块级作用域
```
for (var i = 0; i < 10; i++) {
    (function (i) {
        setTimeout(() => {
            console.log(i);
        }, 1000)
    })(i)
}
```
**改造3**
- 利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入
```
for (var i = 0; i < 10; i++) {
  setTimeout(i => {
    console.log(i);
  }, 1000, i)
}
```
### 33. 下面的代码打印什么内容，为什么？
```
var b = 10;
(function b(){
    b = 20;
    console.log(b); 
})();
```
**输出**
![](./images/1.png)
**解析**
- 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。
- 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。
- IIFE中的函数是函数表达式，而不是函数声明。
  
执行 b = 20 时，顺着作用域链向上找，找到函数 b, 尝试给 b 赋值为 20，由于函数 b 是函数表达式，而函数表达式的函数名是常量，无法二次赋值(在正常模式下静默失效，在严格模式下报错)，赋值失败，所以输出的还是该函数

### 34. 简单改造下面的代码，使之分别打印 10 和 20。
```
var b = 10;
(function b(){
    b = 20;
    console.log(b); 
})();
```
**打印20**：
```
var b = 10;
(function b(b){
    b = 20;
    console.log(b);  //20
})(b);
等价于：
var b = 10;
(function b(){
    var b = 10;
    b = 20;
    console.log(b);  //20
})(b);
```
形参相当于在函数内部定义了`var b = 10`;当执行 b = 20 时，顺着作用域链向上找，于是在函数内找到了局部变量 b(也就是 var b 的), 将其修改为 20。console.log(b)同理，顺着作用域链向上找，找到了局部变量 b，且其值为 20.

**打印10**：
```
var b = 10;
(function b(b){
    console.log(b); //10
    b = 20;
})(b);
等价于：
var b = 10;
(function b(){
    var b = 10;
    console.log(b);  //10
    b = 20;
})(b);
```

### 38. （京东）下面代码中 a 在什么情况下会打印 1？
```
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```
**解法：**
如果一个操作数是对象，另一个操作数不是，则隐式调用对象的toString或valueOf方法。
```
var a = {
    value: 1,
    toString() {
        return this.value++
    }
};
if(a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```